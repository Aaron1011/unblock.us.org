/*** Generated by streamline 0.10.8 (callbacks) - DO NOT EDIT ***/ var __rt=require('streamline/lib/callbacks/runtime').runtime(__filename, false),__func=__rt.__func,__cb=__rt.__cb,__catch=__rt.__catch,__tryCatch=__rt.__tryCatch; (function() {
  var Bottleneck, HTTPSserver, TCPserver, UDPserver, handlerHTTPS, handlerTCP, handlerUDP, libTCP, libUDP, limiterTCP, limiterUDP, serverStarted, services, stats, tcp, udp, util;

  udp = require("dgram");

  tcp = require("net");

  Bottleneck = require("bottleneck");

  util = require("util");

  global.con = function() {
    return util.puts(Array.prototype.slice.call(arguments, 0).map(function(a) {
      return util.inspect(a);
    }).join(" ")); };


  Buffer.prototype.toArray = function() {
    return Array.prototype.slice.call(this, 0); };


  libUDP = require("./dns_udp");

  libTCP = require("./dns_tcp");

  limiterUDP = new Bottleneck(50, 0);

  limiterTCP = new Bottleneck(30, 0);

  stats = {
    nbRequestUDPStart: 0,
    nbFailUDPStart: 0,
    nbRequestUDP: 0,
    nbFailUDP: 0,
    nbRequestTCPStart: 0,
    nbFailTCPStart: 0,
    nbRequestTCP: 0,
    nbFailTCP: 0 };


  services = {
    udp: false,
    tcp: false,
    https: false };


  serverStarted = function(service) {
    services[service] = true;
    if (((services.udp && services.tcp) && services.https)) {
      console.log("Server ready", process.pid);
      process.setuid("nobody");
      return process.send({
        cmd: "online" }); } ; };




  UDPserver = udp.createSocket("udp4");

  UDPserver.on("error", function(err) {
    console.log("----------\n", util.inspect(err), "\n----------");
    return process.exit(); });


  UDPserver.on("listening", function() {
    return serverStarted("udp"); });


  UDPserver.on("close", function() {
    con("UDPserver closed");
    return process.exit(); });


  handlerUDP = function handlerUDP__1(data, info, _) { var err, resData, resInfo, _ref; var __frame = { name: "handlerUDP__1", line: 74 }; return __func(_, this, arguments, handlerUDP__1, 2, __frame, function __$handlerUDP__1() {

      stats.nbRequestUDP++;
      stats.nbRequestUDPStart++; return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$handlerUDP__1() { return (function __$handlerUDP__1(_) {

              return libUDP.forwardGoogleUDP(data, limiterUDP, __cb(_, __frame, 5, 13, function ___(__0, __1) { _ref = __1; resData = _ref[0]; return _(null, resInfo = _ref[1]); }, true, true)); })(__cb(_, __frame, -73, 7, function __$handlerUDP__1() {
              return libUDP.sendUDP(UDPserver, info.address, info.port, resData, __cb(_, __frame, 6, 13, _, true)); }, true)); }); })(function ___(_error, __result) { __catch(function __$handlerUDP__1() { if (_error) {

              err = _error;
              stats.nbFailUDP++;
              stats.nbFailUDPStart++;
              return _(null, console.log(err.message)); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, function __$handlerUDP__1() { _(); }); }); }); };



  UDPserver.on("message", function(data, info) {
    return handlerUDP(data, info, function() {  }); });


  UDPserver.bind(53);

  handlerTCP = function handlerTCP__2(c, _) { var err; var __frame = { name: "handlerTCP__2", line: 95 }; return __func(_, this, arguments, handlerTCP__2, 1, __frame, function __$handlerTCP__2() { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$handlerTCP__2() {


            stats.nbRequestTCP++;
            stats.nbRequestTCPStart++;
            return limiterTCP.submit(libTCP.forwardGoogleTCP, c, __cb(_, __frame, 5, 13, _, true)); }); })(function ___(_error, __result) { __catch(function __$handlerTCP__2() { if (_error) {

              err = _error;
              con(err);
              stats.nbFailTCP++;
              stats.nbFailTCPStart++;
              return _(null, c.destroy()); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, function __$handlerTCP__2() { _(); }); }); }); };



  TCPserver = tcp.createServer(function(c) {
    return handlerTCP(c, function() {  });
  }).listen(53, function() {
    return serverStarted("tcp"); });


  TCPserver.on("error", function(err) {
    console.log("----------\n", util.inspect(err), "\n----------");
    return process.exit(); });


  TCPserver.on("close", function() {
    con("TCPserver closed");
    return process.exit(); });


  handlerHTTPS = function handlerHTTPS__3(c, _) { var __frame = { name: "handlerHTTPS__3", line: 126 }; return __func(_, this, arguments, handlerHTTPS__3, 1, __frame, function __$handlerHTTPS__3() { _(); }); };

  HTTPSserver = tcp.createServer(function(c) {
    return handlerHTTPS(c, function() {  });
  }).listen(443, function() {
    return serverStarted("https"); });


  setInterval(function() {
    if (((limiterUDP._nbRunning > 40) || (limiterTCP._nbRunning > 20))) {
      return con("NBRUNNING: UDP", limiterUDP._nbRunning, "TCP", limiterTCP._nbRunning); } ;

  }, 1000);

  setInterval(function() {
    con(process.pid, "UDP", ((stats.nbFailUDP + "/") + stats.nbRequestUDP), "UDPStart", ((stats.nbFailUDPStart + "/") + stats.nbRequestUDPStart), "TCP", ((stats.nbFailTCP + "/") + stats.nbRequestTCP), "TCPStart", ((stats.nbFailTCPStart + "/") + stats.nbRequestTCPStart));
    stats.nbRequestUDP = 0;
    stats.nbFailUDP = 0;
    stats.nbRequestTCP = 0;
    return stats.nbFailTCP = 0;
  }, 20000);

}).call(this);