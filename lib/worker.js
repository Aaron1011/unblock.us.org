/*** Generated by streamline 0.10.8 (callbacks) - DO NOT EDIT ***/ var __rt=require('streamline/lib/callbacks/runtime').runtime(__filename, false),__func=__rt.__func,__cb=__rt.__cb,__catch=__rt.__catch,__tryCatch=__rt.__tryCatch; (function() {
  var Bottleneck, HTTPSserver, TCPserver, UDPserver, handlerHTTPS, handlerTCP, handlerUDP, libDNS, libHTTPS, libTCP, libUDP, limiterTCP, limiterUDP, serverStarted, services, stats, tcp, udp, util;

  udp = require("dgram");

  tcp = require("net");

  Bottleneck = require("bottleneck");

  util = require("util");

  global.con = function() {
    return util.puts(Array.prototype.concat(new Date().toISOString(), Array.prototype.slice.call(arguments, 0)).map(function(a) {
      return util.inspect(a);
    }).join(" ")); };


  Buffer.prototype.toArray = function() {
    return Array.prototype.slice.call(this, 0); };


  Buffer.prototype.map = function(f) {
    return new Buffer(Array.prototype.map.call(this, f)); };


  Buffer.prototype.reduce = function(f) {
    return Array.prototype.reduce.call(this, f); };


  libUDP = require("./dns_udp");

  libTCP = require("./dns_tcp");

  libDNS = require("./dns");

  libHTTPS = require("./https");

  limiterUDP = new Bottleneck(50, 0);

  limiterTCP = new Bottleneck(30, 0);

  stats = {
    nbRequestUDPStart: 0,
    nbFailUDPStart: 0,
    nbRequestUDP: 0,
    nbFailUDP: 0,
    nbRequestTCPStart: 0,
    nbFailTCPStart: 0,
    nbRequestTCP: 0,
    nbFailTCP: 0 };


  services = { };

  serverStarted = function serverStarted__1(service, _) { var err; var __frame = { name: "serverStarted__1", line: 55 }; return __func(_, this, arguments, serverStarted__1, 1, __frame, function __$serverStarted__1() { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$serverStarted__1() {


            services[service] = true;
            if (((services.udp && services.tcp) && services.https)) {
              process.setuid("nobody");
              console.log("Server ready", process.pid);
              return _(null, process.send({
                cmd: "online" })); } ; __then(); }); })(function ___(_error, __result) { __catch(function __$serverStarted__1() { if (_error) {



              err = _error;
              con(err);
              return _(null, con(err.message)); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, function __$serverStarted__1() { _(); }); }); }); };



  UDPserver = udp.createSocket("udp4");

  UDPserver.on("error", function(err) {
    console.log("----------\n", util.inspect(err), "\n----------");
    return process.exit(); });


  UDPserver.on("listening", function() {
    return serverStarted("udp", false); });


  UDPserver.on("close", function() {
    con("UDPserver closed");
    return process.exit(); });


  handlerUDP = function handlerUDP__2(data, info, _) { var answer, err, parsed, resData, resInfo, _ref; var __frame = { name: "handlerUDP__2", line: 89 }; return __func(_, this, arguments, handlerUDP__2, 2, __frame, function __$handlerUDP__2() {

      stats.nbRequestUDP++;
      stats.nbRequestUDPStart++; return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$handlerUDP__2() {

            parsed = libDNS.parseDNS(data);
            answer = libDNS.getAnswer(parsed); return (function __$handlerUDP__2(__then) {
              if ((answer != null)) {
                resData = answer; __then(); } else { return (function __$handlerUDP__2(_) {

                  return libUDP.forwardGoogleUDP(data, limiterUDP, __cb(_, __frame, 10, 15, function ___(__0, __1) { _ref = __1; resData = _ref[0]; return _(null, resInfo = _ref[1]); }, true, true)); })(__cb(_, __frame, -88, 7, __then, true)); } ; })(function __$handlerUDP__2() {

              return libUDP.sendUDP(UDPserver, info.address, info.port, resData, __cb(_, __frame, 12, 13, _, true)); }); }); })(function ___(_error, __result) { __catch(function __$handlerUDP__2() { if (_error) {

              err = _error;
              stats.nbFailUDP++;
              stats.nbFailUDPStart++;
              return libUDP.sendUDP(UDPserver, info.address, info.port, libDNS.makeDNS(parsed, libDNS.SERVERFAILURE), __cb(_, __frame, 17, 6, function __$handlerUDP__2() {
                return _(null, console.log(err.stack)); }, true)); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, function __$handlerUDP__2() { _(); }); }); }); };



  UDPserver.on("message", function(data, info) {
    var err;
    try {
      return handlerUDP(data, info, function(err) {
        if ((err != null)) {
          throw err; } ; });


    } catch (_error) {
      err = _error;
      return con(err); }; });



  UDPserver.bind(53);

  handlerTCP = function handlerTCP__3(c, _) { var answer, data, err, google, parsed; var __frame = { name: "handlerTCP__3", line: 127 }; return __func(_, this, arguments, handlerTCP__3, 1, __frame, function __$handlerTCP__3() {

      stats.nbRequestTCP++;
      stats.nbRequestTCPStart++; return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$handlerTCP__3() {

            return libTCP.getRequest(c, __cb(_, __frame, 5, 13, function ___(__0, __1) { data = __1;
              parsed = libDNS.parseDNS(data);
              answer = libDNS.getAnswer(parsed, true); return (function __$handlerTCP__3(__then) {
                if ((answer != null)) {
                  return _(null, c.end(answer)); } else {

                  return limiterTCP.submit(libTCP.getGoogleStream, __cb(_, __frame, 11, 17, function ___(__0, __2) { google = __2;
                    google.on("error", function(err) {
                      throw err; });

                    google.on("close", function(hadError) {
                      if (hadError) {
                        throw new Error("GoogleStreamClosed"); } ;

                      return c.destroy(); });

                    google.pipe(c);
                    return _(null, google.write(libDNS.prependLength(data))); }, true)); } ; })(__then); }, true)); }); })(function ___(_error, __result) { __catch(function __$handlerTCP__3() { if (_error) {


              err = _error;
              con(err);
              stats.nbFailTCP++;
              stats.nbFailTCPStart++;
              return _(null, c.destroy()); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, function __$handlerTCP__3() { _(); }); }); }); };



  TCPserver = tcp.createServer(function(c) {
    return handlerTCP(c, function() {  });
  }).listen(53, function() {
    return serverStarted("tcp", false); });


  TCPserver.on("error", function(err) {
    console.log("----------\n", util.inspect(err), "\n----------");
    return process.exit(); });


  TCPserver.on("close", function() {
    con("TCPserver closed");
    return process.exit(); });


  handlerHTTPS = function handlerHTTPS__4(c, _) { var err, host, received, stream, _ref; var __frame = { name: "handlerHTTPS__4", line: 176 }; return __func(_, this, arguments, handlerHTTPS__4, 1, __frame, function __$handlerHTTPS__4() { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$handlerHTTPS__4() { return (function __$handlerHTTPS__4(_) {


              return libHTTPS.getRequest(c, __cb(_, __frame, 3, 13, function ___(__0, __1) { _ref = __1; host = _ref[0]; return _(null, received = _ref[1]); }, true, true)); })(__cb(_, __frame, -175, 7, function __$handlerHTTPS__4() {
              return libHTTPS.getHTTPSstream(host, __cb(_, __frame, 4, 15, function ___(__0, __1) { stream = __1;
                con(host);
                con(received);
                stream.pipe(c);
                stream.write(received);
                return _(null, c.pipe(stream)); }, true)); }, true)); }); })(function ___(_error, __result) { __catch(function __$handlerHTTPS__4() { if (_error) {

              err = _error;
              return _(null, con(err)); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, function __$handlerHTTPS__4() { _(); }); }); }); };



  HTTPSserver = tcp.createServer(function(c) {
    con("listeninnnnng");
    return handlerHTTPS(c, function() {  });
  }).listen(443, function() {
    con("!!!");
    return serverStarted("https", false); });


  HTTPSserver.on("error", function(err) {
    console.log("----------\n", util.inspect(err), "\n", err.message, "\n----------");
    return process.exit(); });


  HTTPSserver.on("close", function() {
    con("HTTPSserver closed");
    return process.exit(); });


  setInterval(function() {
    if (((limiterUDP._nbRunning > 40) || (limiterTCP._nbRunning > 20))) {
      return con("NBRUNNING: UDP", limiterUDP._nbRunning, "TCP", limiterTCP._nbRunning); } ;

  }, 3000);

  setInterval(function() {
    con(process.pid, "UDP", ((stats.nbFailUDP + "/") + stats.nbRequestUDP), "UDPStart", ((stats.nbFailUDPStart + "/") + stats.nbRequestUDPStart), "TCP", ((stats.nbFailTCP + "/") + stats.nbRequestTCP), "TCPStart", ((stats.nbFailTCPStart + "/") + stats.nbRequestTCPStart));
    stats.nbRequestUDP = 0;
    stats.nbFailUDP = 0;
    stats.nbRequestTCP = 0;
    return stats.nbFailTCP = 0;
  }, (60 * 1000));

}).call(this);