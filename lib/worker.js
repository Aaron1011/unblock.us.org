/*** Generated by streamline 0.10.8 (callbacks) - DO NOT EDIT ***/ var __rt=require('streamline/lib/callbacks/runtime').runtime(__filename, false),__func=__rt.__func,__cb=__rt.__cb,__catch=__rt.__catch,__tryCatch=__rt.__tryCatch; (function() {
  var Bottleneck, HTTPSserver, HTTPserver, TCPserver, UDPserver, handlerHTTP_S, handlerTCP, handlerUDP, libRedirect, libTCP, libUDP, limiterTCP, limiterUDP, serverStarted, services, stats, tcp, udp, util;

  udp = require("dgram");

  tcp = require("net");

  Bottleneck = require("bottleneck");

  util = require("util");

  global.con = function() {
    return util.puts(Array.prototype.slice.call(arguments, 0).map(function(a) {
      return util.inspect(a);
    }).join(" ")); };


  Buffer.prototype.toArray = function() {
    return Array.prototype.slice.call(this, 0); };


  libUDP = require("./dns_udp");

  libTCP = require("./dns_tcp");

  libRedirect = require("./redirect");

  limiterUDP = new Bottleneck(50, 0);

  limiterTCP = new Bottleneck(30, 0);

  stats = {
    nbRequestUDPStart: 0,
    nbFailUDPStart: 0,
    nbRequestUDP: 0,
    nbFailUDP: 0,
    nbRequestTCPStart: 0,
    nbFailTCPStart: 0,
    nbRequestTCP: 0,
    nbFailTCP: 0 };


  services = { };

  serverStarted = function(service) {
    services[service] = true;
    if ((((services.udp && services.tcp) && services.https) && services.http)) {
      console.log("Server ready", process.pid);
      process.setuid("nobody");
      return process.send({
        cmd: "online" }); } ; };




  UDPserver = udp.createSocket("udp4");

  UDPserver.on("error", function(err) {
    console.log("----------\n", util.inspect(err), "\n----------");
    return process.exit(); });


  UDPserver.on("listening", function() {
    return serverStarted("udp"); });


  UDPserver.on("close", function() {
    con("UDPserver closed");
    return process.exit(); });


  handlerUDP = function handlerUDP__1(data, info, _) { var answer, err, parsed, resData, resInfo, _ref; var __frame = { name: "handlerUDP__1", line: 72 }; return __func(_, this, arguments, handlerUDP__1, 2, __frame, function __$handlerUDP__1() {

      stats.nbRequestUDP++;
      stats.nbRequestUDPStart++; return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$handlerUDP__1() {

            parsed = libRedirect.parseUDP(data);
            answer = libRedirect.getAnswer(parsed); return (function __$handlerUDP__1(__then) {
              if ((answer != null)) {
                resData = answer; __then(); } else { return (function __$handlerUDP__1(_) {

                  return libUDP.forwardGoogleUDP(data, limiterUDP, __cb(_, __frame, 10, 15, function ___(__0, __1) { _ref = __1; resData = _ref[0]; return _(null, resInfo = _ref[1]); }, true, true)); })(__cb(_, __frame, -71, 7, __then, true)); } ; })(function __$handlerUDP__1() {

              return libUDP.sendUDP(UDPserver, info.address, info.port, resData, __cb(_, __frame, 12, 13, _, true)); }); }); })(function ___(_error, __result) { __catch(function __$handlerUDP__1() { if (_error) {

              err = _error;
              stats.nbFailUDP++;
              stats.nbFailUDPStart++;
              return libUDP.sendUDP(UDPserver, info.address, info.port, libRedirect.makeUDP(parsed, libRedirect.SERVERFAILURE), __cb(_, __frame, 17, 6, function __$handlerUDP__1() {
                return _(null, console.log(err.message)); }, true)); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, function __$handlerUDP__1() { _(); }); }); }); };



  UDPserver.on("message", function(data, info) {
    var err;
    try {
      return handlerUDP(data, info, function() {  });
    } catch (_error) {
      err = _error;
      return con(err); }; });



  UDPserver.bind(53);

  handlerTCP = function handlerTCP__2(c, _) { var err; var __frame = { name: "handlerTCP__2", line: 106 }; return __func(_, this, arguments, handlerTCP__2, 1, __frame, function __$handlerTCP__2() { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$handlerTCP__2() {


            stats.nbRequestTCP++;
            stats.nbRequestTCPStart++;
            return limiterTCP.submit(libTCP.forwardGoogleTCP, c, __cb(_, __frame, 5, 13, _, true)); }); })(function ___(_error, __result) { __catch(function __$handlerTCP__2() { if (_error) {

              err = _error;
              con(err);
              stats.nbFailTCP++;
              stats.nbFailTCPStart++;
              return _(null, c.destroy()); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, function __$handlerTCP__2() { _(); }); }); }); };



  TCPserver = tcp.createServer(function(c) {
    return handlerTCP(c, function() {  });
  }).listen(53, function() {
    return serverStarted("tcp"); });


  TCPserver.on("error", function(err) {
    console.log("----------\n", util.inspect(err), "\n----------");
    return process.exit(); });


  TCPserver.on("close", function() {
    con("TCPserver closed");
    return process.exit(); });


  handlerHTTP_S = function handlerHTTP_S__3(c, port, _) { var google; var __frame = { name: "handlerHTTP_S__3", line: 137 }; return __func(_, this, arguments, handlerHTTP_S__3, 2, __frame, function __$handlerHTTP_S__3() {

      return _(null, google = tcp.createConnection({
        port: port,
        host: "199.59.149.198"
      }, function() {
        con("PIPING!", port);
        return c.pipe(google).pipe(c); })); }); };



  HTTPSserver = tcp.createServer(function(c) {
    return handlerHTTP_S(c, 443, function() {  });
  }).listen(443, function() {
    return serverStarted("https"); });


  HTTPserver = tcp.createServer(function(c) {
    return handlerHTTP_S(c, 80, function() {  });
  }).listen(80, function() {
    return serverStarted("http"); });


  setInterval(function() {
    if (((limiterUDP._nbRunning > 40) || (limiterTCP._nbRunning > 20))) {
      return con("NBRUNNING: UDP", limiterUDP._nbRunning, "TCP", limiterTCP._nbRunning); } ;

  }, 3000);

  setInterval(function() {
    con(process.pid, "UDP", ((stats.nbFailUDP + "/") + stats.nbRequestUDP), "UDPStart", ((stats.nbFailUDPStart + "/") + stats.nbRequestUDPStart), "TCP", ((stats.nbFailTCP + "/") + stats.nbRequestTCP), "TCPStart", ((stats.nbFailTCPStart + "/") + stats.nbRequestTCPStart));
    stats.nbRequestUDP = 0;
    stats.nbFailUDP = 0;
    stats.nbRequestTCP = 0;
    return stats.nbFailTCP = 0;
  }, 30000);

}).call(this);