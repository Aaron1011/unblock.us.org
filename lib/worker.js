/*** Generated by streamline 0.10.8 (callbacks) - DO NOT EDIT ***/ var __rt=require('streamline/lib/callbacks/runtime').runtime(__filename, false),__func=__rt.__func,__cb=__rt.__cb,__catch=__rt.__catch,__tryCatch=__rt.__tryCatch; (function() {
  var Bottleneck, HTTPSserver, TCPserver, UDPserver, countryStats, geoip, handlerHTTPS, handlerTCP, handlerUDP, libDNS, libHTTPS, libTCP, libUDP, limiterHTTPS, limiterTCP, limiterUDP, serverStarted, services, settings, shutdown, stats, tcp, udp, util;

  udp = require("dgram");

  tcp = require("net");

  Bottleneck = require("bottleneck");

  geoip = require("geoip-lite");

  util = require("util");

  settings = require("../settings");

  global.con = function() {
    return console.log(Array.prototype.concat(new Date().toISOString(), Array.prototype.slice.call(arguments, 0)).map(function(a) {
      return util.inspect(a);
    }).join(" ")); };


  Buffer.prototype.toArray = function() {
    return Array.prototype.slice.call(this, 0); };


  Buffer.prototype.map = function(f) {
    return new Buffer(Array.prototype.map.call(this, f)); };


  Buffer.prototype.reduce = function(f) {
    return Array.prototype.reduce.call(this, f); };


  libUDP = require("./dns_udp");

  libTCP = require("./dns_tcp");

  libDNS = require("./dns");

  libHTTPS = require("./https");

  limiterUDP = new Bottleneck(50, 0);

  limiterTCP = new Bottleneck(30, 0);

  limiterHTTPS = new Bottleneck(120, 0);

  stats = {
    nbRequestUDPStart: 0,
    nbFailUDPStart: 0,
    nbRequestUDP: 0,
    nbFailUDP: 0,
    nbRequestTCPStart: 0,
    nbFailTCPStart: 0,
    nbRequestTCP: 0,
    nbFailTCP: 0,
    nbRequestHTTPSStart: 0,
    nbFailHTTPSStart: 0,
    nbRequestHTTPS: 0,
    nbFailHTTPS: 0,
    countriesDNS: { },
    countriesHTTPS: { } };


  countryStats = function(ip, type) {
    var country, err, hashmap, _ref;
    try {
      country = (((_ref = geoip.lookup(ip)) != null) ? _ref.country : void 0);
      if ((country == null)) {
        throw new Error(("Can't lookup " + ip)); } ;

      hashmap = ((type === "DNS") ? stats.countriesDNS : stats.countriesHTTPS);
      if ((hashmap[country] != null)) {
        return hashmap[country]++; }
       else {
        return hashmap[country] = 0; } ;

    } catch (_error) {
      err = _error;
      return con(err); }; };



  shutdown = function shutdown__1(cause, _) { var f1, f2; var __frame = { name: "shutdown__1", line: 84 }; return __func(_, this, arguments, shutdown__1, 1, __frame, function __$shutdown__1() {

      shutdown = function() {  };
      con("worker PID", process.pid, "is shutting down:", cause);
      f1 = TCPserver.close(false);
      f2 = HTTPSserver.close(false);
      UDPserver.close();
      setTimeout((function() {
        return process.exit();
      }), 10000);
      return f1(__cb(_, __frame, 10, 4, function __$shutdown__1() {
        return f2(__cb(_, __frame, 11, 4, function __$shutdown__1() {
          return _(null, process.exit()); }, true)); }, true)); }); };


  process.on("SIGTERM", function() {
    return shutdown("SIGTERM", function() {  }); });


  services = { };

  serverStarted = function(service) {
    var err;
    try {
      services[service] = true;
      if (((services.udp && services.tcp) && services.https)) {
        process.setuid("nobody");
        console.log("Server ready", process.pid);
        return process.send({
          cmd: "online" }); } ;


    } catch (_error) {
      err = _error;
      con(err);
      return con(err.message); }; };



  UDPserver = udp.createSocket("udp4");

  UDPserver.on("error", function(err) {
    return shutdown(((("UDPserver error " + util.inspect(err)) + " ") + err.message), function() {  }); });


  UDPserver.on("listening", function() {
    return serverStarted("udp"); });


  UDPserver.on("close", function() {
    return shutdown("UDPserver closed", function() {  }); });


  handlerUDP = function handlerUDP__2(data, info, _) { var answer, e, err, parsed, resData, resInfo, _ref; var __frame = { name: "handlerUDP__2", line: 137 }; return __func(_, this, arguments, handlerUDP__2, 2, __frame, function __$handlerUDP__2() {

      stats.nbRequestUDP++;
      stats.nbRequestUDPStart++; return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$handlerUDP__2() {

            parsed = libDNS.parseDNS(data);
            answer = libDNS.getAnswer(parsed); return (function __$handlerUDP__2(__then) {
              if ((answer != null)) {
                resData = answer; __then(); } else { return (function __$handlerUDP__2(_) {

                  return libUDP.forwardGoogleUDP(data, limiterUDP, __cb(_, __frame, 10, 15, function ___(__0, __1) { _ref = __1; resData = _ref[0]; return _(null, resInfo = _ref[1]); }, true, true)); })(__cb(_, __frame, -136, 7, __then, true)); } ; })(function __$handlerUDP__2() {

              return libUDP.sendUDP(UDPserver, info.address, info.port, resData, __cb(_, __frame, 12, 6, function __$handlerUDP__2() {
                return _(null, countryStats(info.address, "DNS")); }, true)); }); }); })(function ___(_error, __result) { __catch(function __$handlerUDP__2() { if (_error) {

              err = _error;
              stats.nbFailUDP++;
              stats.nbFailUDPStart++; return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$handlerUDP__2() {

                    return libUDP.sendUDP(UDPserver, info.address, info.port, libDNS.makeDNS(parsed, libDNS.SERVERFAILURE), __cb(_, __frame, 19, 8, __then, true)); }); })(function ___(_error, __result) { __catch(function __$handlerUDP__2() { if (_error) {

                      e = _error; __then(); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, function __$handlerUDP__2() {

                  return _(null, con(err.message)); }); }); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, function __$handlerUDP__2() { _(); }); }); }); };



  UDPserver.on("message", function(data, info) {
    var err;
    try {
      return handlerUDP(data, info, function(err) {
        if ((err != null)) {
          throw err; } ; });


    } catch (_error) {
      err = _error;
      return con(err); }; });



  UDPserver.bind(53);

  handlerTCP = function handlerTCP__3(c, _) { var answer, data, err, google, parsed; var __frame = { name: "handlerTCP__3", line: 180 }; return __func(_, this, arguments, handlerTCP__3, 1, __frame, function __$handlerTCP__3() {

      stats.nbRequestTCP++;
      stats.nbRequestTCPStart++; return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$handlerTCP__3() {

            return libTCP.getRequest(c, __cb(_, __frame, 5, 13, function ___(__0, __1) { data = __1;
              parsed = libDNS.parseDNS(data);
              answer = libDNS.getAnswer(parsed, true); return (function __$handlerTCP__3(__then) {
                if ((answer != null)) {
                  c.end(answer); __then(); } else {

                  return limiterTCP.submit(libTCP.getGoogleStream, __cb(_, __frame, 11, 17, function ___(__0, __2) { google = __2;
                    google.pipe(c);
                    google.write(libDNS.prependLength(data)); __then(); }, true)); } ; })(function __$handlerTCP__3() {

                return _(null, countryStats(c.remoteAddress, "DNS")); }); }, true)); }); })(function ___(_error, __result) { __catch(function __$handlerTCP__3() { if (_error) {

              err = _error;
              con(err);
              stats.nbFailTCP++;
              stats.nbFailTCPStart++;
              return _(null, c.destroy()); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, function __$handlerTCP__3() { _(); }); }); }); };



  TCPserver = tcp.createServer(function(c) {
    return handlerTCP(c, function() {  });
  }).listen(53, function() {
    return serverStarted("tcp"); });


  TCPserver.on("error", function(err) {
    return shutdown(((("TCPserver error " + util.inspect(err)) + " ") + err.message), function() {  }); });


  TCPserver.on("close", function() {
    return shutdown("TCPserver closed", function() {  }); });


  handlerHTTPS = function handlerHTTPS__4(c, _) { var err, host, received, stream, _ref; var __frame = { name: "handlerHTTPS__4", line: 219 }; return __func(_, this, arguments, handlerHTTPS__4, 1, __frame, function __$handlerHTTPS__4() {

      stats.nbRequestHTTPS++;
      stats.nbRequestHTTPSStart++; return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$handlerHTTPS__4() { return (function __$handlerHTTPS__4(_) {

              return libHTTPS.getRequest(c, __cb(_, __frame, 5, 13, function ___(__0, __1) { _ref = __1; host = _ref[0]; return _(null, received = _ref[1]); }, true, true)); })(__cb(_, __frame, -218, 7, function __$handlerHTTPS__4() {
              if ((settings.hijacked[host.split(".").slice(-2).join(".")] == null)) {
                return _(new Error(("Domain not found: " + host))); } ;

              return limiterHTTPS.submit(libHTTPS.getHTTPSstream, host, __cb(_, __frame, 9, 15, function ___(__0, __1) { stream = __1;
                stream.write(received);
                c.pipe(stream).pipe(c);
                c.resume();
                return _(null, countryStats(c.remoteAddress, "HTTPS")); }, true)); }, true)); }); })(function ___(_error, __result) { __catch(function __$handlerHTTPS__4() { if (_error) {

              err = _error;
              con(err.message);
              stats.nbFailHTTPS++;
              stats.nbFailHTTPSStart++;
              if ((c != null)) {
                if ((typeof c.destroy === "function")) {
                  c.destroy(); } ; } ;


              return _(null, ((stream != null) ? ((typeof stream.destroy === "function") ? stream.destroy() : void 0) : void 0)); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, function __$handlerHTTPS__4() { _(); }); }); }); };



  HTTPSserver = tcp.createServer(function(c) {
    return handlerHTTPS(c, function() {  });
  }).listen(443, function() {
    return serverStarted("https"); });


  HTTPSserver.on("error", function(err) {
    return shutdown(((("HTTPSserver error " + util.inspect(err)) + " ") + err.message), function() {  }); });


  HTTPSserver.on("close", function() {
    return shutdown("HTTPSserver closed", function() {  }); });


  setInterval(function() {
    if ((((limiterUDP._nbRunning > 40) || (limiterTCP._nbRunning > 20)) || (limiterHTTPS._nbRunning > 100))) {
      return con("NBRUNNING: UDP", limiterUDP._nbRunning, "TCP", limiterTCP._nbRunning, "HTTPS", limiterHTTPS._nbRunning); } ;

  }, 3000);

  setInterval(function() {
    con(stats.countriesDNS);
    return con(stats.countriesHTTPS);
  }, ((60 * 10) * 1000));

  setInterval(function() {
    con(process.pid, "UDP", ((stats.nbFailUDP + "/") + stats.nbRequestUDP), "UDPStart", ((stats.nbFailUDPStart + "/") + stats.nbRequestUDPStart), "TCP", ((stats.nbFailTCP + "/") + stats.nbRequestTCP), "TCPStart", ((stats.nbFailTCPStart + "/") + stats.nbRequestTCPStart), "HTTPS", ((stats.nbFailHTTPS + "/") + stats.nbRequestHTTPS), "HTTPSStart", ((stats.nbFailHTTPSStart + "/") + stats.nbRequestHTTPSStart));
    stats.nbRequestUDP = 0;
    stats.nbFailUDP = 0;
    stats.nbRequestTCP = 0;
    stats.nbFailTCP = 0;
    stats.nbRequestHTTPS = 0;
    return stats.nbFailHTTPS = 0;
  }, (60 * 1000));

}).call(this);