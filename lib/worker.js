/*** Generated by streamline 0.10.8 (callbacks) - DO NOT EDIT ***/ var __rt=require('streamline/lib/callbacks/runtime').runtime(__filename, false),__func=__rt.__func,__cb=__rt.__cb,__catch=__rt.__catch,__tryCatch=__rt.__tryCatch; (function() {
  var Bottleneck, TCPserver, UDPserver, handlerTCP, handlerUDP, libDNS, libTCP, libUDP, limiterTCP, limiterUDP, serverStarted, services, stats, stream, tcp, udp, util;

  udp = require("dgram");

  tcp = require("net");

  Bottleneck = require("bottleneck");

  util = require("util");

  stream = require("stream");

  global.con = function() {
    return util.puts(Array.prototype.concat(new Date().toISOString(), Array.prototype.slice.call(arguments, 0)).map(function(a) {
      return util.inspect(a);
    }).join(" ")); };


  Buffer.prototype.toArray = function() {
    return Array.prototype.slice.call(this, 0); };


  Buffer.prototype.map = function(f) {
    return new Buffer(Array.prototype.map.call(this, f)); };


  Buffer.prototype.reduce = function(f) {
    return Array.prototype.reduce.call(this, f); };


  libUDP = require("./dns_udp");

  libTCP = require("./dns_tcp");

  libDNS = require("./dns");

  limiterUDP = new Bottleneck(50, 0);

  limiterTCP = new Bottleneck(30, 0);

  stats = {
    nbRequestUDPStart: 0,
    nbFailUDPStart: 0,
    nbRequestUDP: 0,
    nbFailUDP: 0,
    nbRequestTCPStart: 0,
    nbFailTCPStart: 0,
    nbRequestTCP: 0,
    nbFailTCP: 0 };


  services = { };

  serverStarted = function(service) {
    services[service] = true;
    if ((services.udp && services.tcp)) {
      console.log("Server ready", process.pid);
      process.setuid("nobody");
      return process.send({
        cmd: "online" }); } ; };




  UDPserver = udp.createSocket("udp4");

  UDPserver.on("error", function(err) {
    console.log("----------\n", util.inspect(err), "\n----------");
    return process.exit(); });


  UDPserver.on("listening", function() {
    return serverStarted("udp"); });


  UDPserver.on("close", function() {
    con("UDPserver closed");
    return process.exit(); });


  handlerUDP = function handlerUDP__1(data, info, _) { var answer, err, parsed, resData, resInfo, _ref; var __frame = { name: "handlerUDP__1", line: 82 }; return __func(_, this, arguments, handlerUDP__1, 2, __frame, function __$handlerUDP__1() {

      stats.nbRequestUDP++;
      stats.nbRequestUDPStart++; return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$handlerUDP__1() {

            parsed = libDNS.parseDNS(data);
            answer = libDNS.getAnswer(parsed); return (function __$handlerUDP__1(__then) {
              if ((answer != null)) {
                resData = answer; __then(); } else { return (function __$handlerUDP__1(_) {

                  return libUDP.forwardGoogleUDP(data, limiterUDP, __cb(_, __frame, 10, 15, function ___(__0, __1) { _ref = __1; resData = _ref[0]; return _(null, resInfo = _ref[1]); }, true, true)); })(__cb(_, __frame, -81, 7, __then, true)); } ; })(function __$handlerUDP__1() {

              return libUDP.sendUDP(UDPserver, info.address, info.port, resData, __cb(_, __frame, 12, 13, _, true)); }); }); })(function ___(_error, __result) { __catch(function __$handlerUDP__1() { if (_error) {

              err = _error;
              stats.nbFailUDP++;
              stats.nbFailUDPStart++;
              return libUDP.sendUDP(UDPserver, info.address, info.port, libDNS.makeDNS(parsed, libDNS.SERVERFAILURE), __cb(_, __frame, 17, 6, function __$handlerUDP__1() {
                return _(null, console.log(err.message)); }, true)); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, function __$handlerUDP__1() { _(); }); }); }); };



  UDPserver.on("message", function(data, info) {
    var err;
    try {
      return handlerUDP(data, info, function(err) {
        if ((err != null)) {
          throw err; } ; });


    } catch (_error) {
      err = _error;
      return con(err); }; });



  UDPserver.bind(53);

  handlerTCP = function handlerTCP__2(c, _) { var answer, data, err, google, parsed; var __frame = { name: "handlerTCP__2", line: 120 }; return __func(_, this, arguments, handlerTCP__2, 1, __frame, function __$handlerTCP__2() {

      stats.nbRequestTCP++;
      stats.nbRequestTCPStart++; return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$handlerTCP__2() {

            return libTCP.getRequest(c, __cb(_, __frame, 5, 13, function ___(__0, __1) { data = __1;
              parsed = libDNS.parseDNS(data);
              answer = libDNS.getAnswer(parsed, true); return (function __$handlerTCP__2(__then) {
                if ((answer != null)) {
                  return _(null, c.end(answer)); } else {

                  return limiterTCP.submit(libTCP.getGoogleStream, __cb(_, __frame, 11, 17, function ___(__0, __2) { google = __2;
                    google.on("error", function(err) {
                      throw err; });

                    google.on("close", function(hadError) {
                      if (hadError) {
                        throw new Error("GoogleStreamClosed"); } ;

                      return c.destroy(); });

                    google.pipe(c);
                    return _(null, google.write(libDNS.prependLength(data))); }, true)); } ; })(__then); }, true)); }); })(function ___(_error, __result) { __catch(function __$handlerTCP__2() { if (_error) {


              err = _error;
              con(err);
              stats.nbFailTCP++;
              stats.nbFailTCPStart++;
              return _(null, c.destroy()); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, function __$handlerTCP__2() { _(); }); }); }); };



  TCPserver = tcp.createServer(function(c) {
    return handlerTCP(c, function() {  });
  }).listen(53, function() {
    return serverStarted("tcp"); });


  TCPserver.on("error", function(err) {
    console.log("----------\n", util.inspect(err), "\n----------");
    return process.exit(); });


  TCPserver.on("close", function() {
    con("TCPserver closed");
    return process.exit(); });


  setInterval(function() {
    if (((limiterUDP._nbRunning > 40) || (limiterTCP._nbRunning > 20))) {
      return con("NBRUNNING: UDP", limiterUDP._nbRunning, "TCP", limiterTCP._nbRunning); } ;

  }, 3000);

  setInterval(function() {
    con(process.pid, "UDP", ((stats.nbFailUDP + "/") + stats.nbRequestUDP), "UDPStart", ((stats.nbFailUDPStart + "/") + stats.nbRequestUDPStart), "TCP", ((stats.nbFailTCP + "/") + stats.nbRequestTCP), "TCPStart", ((stats.nbFailTCPStart + "/") + stats.nbRequestTCPStart));
    stats.nbRequestUDP = 0;
    stats.nbFailUDP = 0;
    stats.nbRequestTCP = 0;
    return stats.nbFailTCP = 0;
  }, 30000);

}).call(this);